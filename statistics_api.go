/*
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * API version: 5
 * Contact: sdk@isilon.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package isi_sdk_8_1_0

import (
	"io/ioutil"
	"net/url"
	"net/http"
	"strings"
	"golang.org/x/net/context"
	"encoding/json"
	"fmt"
)

// Linger please
var (
	_ context.Context
)

type StatisticsApiService service


/* StatisticsApiService 
 Retrieve stats.
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "timeout" (int32) Time in seconds to wait for results from remote nodes.
     @param "showNodes" (bool) Shows the logical node number or LNN in addition to the devid.
     @param "keys" ([]string) Multiple key names. May request matching keys or request &#39;all&#39; keys. Can be comma separated list or can be used more than one time to make queries for multiple keys. May be used in conjunction with &#39;substr&#39;. Also works with &#39;key&#39; arguments.
     @param "devid" ([]string) Node devid to query. Either an &lt;integer&gt; or \&quot;all\&quot;. Can be used more than one time to query multiple nodes. \&quot;all\&quot; queries all up nodes. 0 means query the local node. For \&quot;cluster\&quot; scoped keys, in any devid including 0 can be used.
     @param "substr" (bool) Used in conjunction with the &#39;keys&#39; argument, alters the behavior of keys. Makes the &#39;keys&#39; arg perform a partial match. Defaults to false.
     @param "stale" (bool) For internal use only, please do not use this.
     @param "typeInfo" (bool) The type ID is used by internal services. For internal use only, please do not use this.
     @param "raw" (bool) Causes the output to be in hex format. For internal use only, please do not use this.
     @param "key" ([]string) One key name. Can be used more than one time to query multiple keys. Also works with &#39;keys&#39; arguments.
     @param "degraded" (bool) If true, try to continue even if some stats are unavailable. In this case, errors will be present in the per-key returned data.
     @param "nodes" ([]string) Specify node(s) for which statistics should be reported. One or more comma separated &lt;integer(s)&gt; specifying which node(s) to query, or \&quot;all\&quot;. Specifying more than one node may have unspecified results for keys that begin with \&quot;cluster\&quot;.
 @return StatisticsCurrent*/
func (a *StatisticsApiService) GetStatisticsCurrent(ctx context.Context, localVarOptionals map[string]interface{}) (StatisticsCurrent,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  StatisticsCurrent
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/platform/1/statistics/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["timeout"], "int32", "timeout"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["showNodes"], "bool", "showNodes"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["substr"], "bool", "substr"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["stale"], "bool", "stale"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["typeInfo"], "bool", "typeInfo"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["raw"], "bool", "raw"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["degraded"], "bool", "degraded"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["timeout"].(int32); localVarOk {
		localVarQueryParams.Add("timeout", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["showNodes"].(bool); localVarOk {
		localVarQueryParams.Add("show_nodes", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["keys"].([]string); localVarOk {
		localVarQueryParams.Add("keys", parameterToString(localVarTempParam, "csv"))
	}
	if localVarTempParam, localVarOk := localVarOptionals["devid"].([]string); localVarOk {
		localVarQueryParams.Add("devid", parameterToString(localVarTempParam, "csv"))
	}
	if localVarTempParam, localVarOk := localVarOptionals["substr"].(bool); localVarOk {
		localVarQueryParams.Add("substr", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["stale"].(bool); localVarOk {
		localVarQueryParams.Add("stale", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["typeInfo"].(bool); localVarOk {
		localVarQueryParams.Add("type_info", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["raw"].(bool); localVarOk {
		localVarQueryParams.Add("raw", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["key"].([]string); localVarOk {
		localVarQueryParams.Add("key", parameterToString(localVarTempParam, "csv"))
	}
	if localVarTempParam, localVarOk := localVarOptionals["degraded"].(bool); localVarOk {
		localVarQueryParams.Add("degraded", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["nodes"].([]string); localVarOk {
		localVarQueryParams.Add("nodes", parameterToString(localVarTempParam, "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* StatisticsApiService 
 Retrieve stats.
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "begin" (int32) Earliest time (Unix epoch seconds) of interest. Negative times are interpreted as relative (before) now.
     @param "interval" (int32) Minimum sampling interval time in seconds. If native statistics are higher resolution, data will be down-sampled.
     @param "end" (int32) Latest time (Unix epoch seconds) of interest. Negative times are interpreted as relative (before) now. If not supplied, use now as the end time.
     @param "timeout" (int32) Time in seconds to wait for results from remote nodes.
     @param "raw" (bool) Causes the output to be in hex format. For internal use only, please do not use this.
     @param "keys" ([]string) Multiple key names. May request matching keys or request &#39;all&#39; keys. Can be comma separated list or can be used more than one time to make queries for multiple keys. May be used in conjunction with &#39;substr&#39;. Also works with &#39;key&#39; arguments.
     @param "devid" ([]string) Node devid to query. Either an &lt;integer&gt; or \&quot;all\&quot;. Can be used more than one time to query multiple nodes. \&quot;all\&quot; queries all up nodes. 0 means query the local node. For \&quot;cluster\&quot; scoped keys, in any devid including 0 can be used.
     @param "substr" (bool) Used in conjunction with the &#39;keys&#39; argument, alters the behavior of keys. Makes the &#39;keys&#39; arg perform a partial match. Defaults to false.
     @param "stale" (bool) For internal use only, please do not use this.
     @param "typeInfo" (bool) The type ID is used by internal services. For internal use only, please do not use this.
     @param "memoryOnly" (bool) Only use statistics sources that reside in memory (faster, but with less retention).
     @param "key" ([]string) One key name. Can be used more than one time to query multiple keys. Also works with &#39;keys&#39; arguments.
     @param "degraded" (bool) If true, try to continue even if some stats are unavailable. In this case, errors will be present in the per-key returned data.
     @param "showNodes" (bool) Shows the logical node number or LNN in addition to the devid.
     @param "resolution" (int32) Synonymous with &#39;interval&#39;, if supplied supersedes interval.
     @param "nodes" ([]string) Specify node(s) for which statistics should be reported. One or more comma separated &lt;integer(s)&gt; specifying which node(s) to query, or \&quot;all\&quot;. Specifying more than one node may have unspecified results for keys that begin with \&quot;cluster\&quot;.
 @return StatisticsHistory*/
func (a *StatisticsApiService) GetStatisticsHistory(ctx context.Context, localVarOptionals map[string]interface{}) (StatisticsHistory,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  StatisticsHistory
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/platform/1/statistics/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["begin"], "int32", "begin"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["interval"], "int32", "interval"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["end"], "int32", "end"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["timeout"], "int32", "timeout"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["raw"], "bool", "raw"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["substr"], "bool", "substr"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["stale"], "bool", "stale"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["typeInfo"], "bool", "typeInfo"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["memoryOnly"], "bool", "memoryOnly"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["degraded"], "bool", "degraded"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["showNodes"], "bool", "showNodes"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["resolution"], "int32", "resolution"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["begin"].(int32); localVarOk {
		localVarQueryParams.Add("begin", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["interval"].(int32); localVarOk {
		localVarQueryParams.Add("interval", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["end"].(int32); localVarOk {
		localVarQueryParams.Add("end", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["timeout"].(int32); localVarOk {
		localVarQueryParams.Add("timeout", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["raw"].(bool); localVarOk {
		localVarQueryParams.Add("raw", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["keys"].([]string); localVarOk {
		localVarQueryParams.Add("keys", parameterToString(localVarTempParam, "csv"))
	}
	if localVarTempParam, localVarOk := localVarOptionals["devid"].([]string); localVarOk {
		localVarQueryParams.Add("devid", parameterToString(localVarTempParam, "csv"))
	}
	if localVarTempParam, localVarOk := localVarOptionals["substr"].(bool); localVarOk {
		localVarQueryParams.Add("substr", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["stale"].(bool); localVarOk {
		localVarQueryParams.Add("stale", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["typeInfo"].(bool); localVarOk {
		localVarQueryParams.Add("type_info", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["memoryOnly"].(bool); localVarOk {
		localVarQueryParams.Add("memory_only", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["key"].([]string); localVarOk {
		localVarQueryParams.Add("key", parameterToString(localVarTempParam, "csv"))
	}
	if localVarTempParam, localVarOk := localVarOptionals["degraded"].(bool); localVarOk {
		localVarQueryParams.Add("degraded", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["showNodes"].(bool); localVarOk {
		localVarQueryParams.Add("show_nodes", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["resolution"].(int32); localVarOk {
		localVarQueryParams.Add("resolution", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["nodes"].([]string); localVarOk {
		localVarQueryParams.Add("nodes", parameterToString(localVarTempParam, "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* StatisticsApiService 
 List key meta-data.
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param statisticsKeyId List key meta-data.
 @return StatisticsKeys*/
func (a *StatisticsApiService) GetStatisticsKey(ctx context.Context, statisticsKeyId string) (StatisticsKeys,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  StatisticsKeys
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/platform/1/statistics/keys/{StatisticsKeyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"StatisticsKeyId"+"}", fmt.Sprintf("%v", statisticsKeyId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* StatisticsApiService 
 List meta-data for matching keys.
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "count" (bool) Only count matching keys, do not return meta-data.
     @param "limit" (int32) Return no more than this many results at once (see resume).
     @param "queryable" (bool) Only list keys that can/cannot be queries. Default is true.
     @param "resume" (string) Continue returning results from previous call using this token (token should come from the previous call, resume cannot be used with other options).
 @return StatisticsKeysExtended*/
func (a *StatisticsApiService) GetStatisticsKeys(ctx context.Context, localVarOptionals map[string]interface{}) (StatisticsKeysExtended,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  StatisticsKeysExtended
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/platform/1/statistics/keys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["count"], "bool", "count"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["limit"], "int32", "limit"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["queryable"], "bool", "queryable"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["resume"], "string", "resume"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["count"].(bool); localVarOk {
		localVarQueryParams.Add("count", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["limit"].(int32); localVarOk {
		localVarQueryParams.Add("limit", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["queryable"].(bool); localVarOk {
		localVarQueryParams.Add("queryable", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["resume"].(string); localVarOk {
		localVarQueryParams.Add("resume", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* StatisticsApiService 
 Retrieve operations list.
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "protocols" ([]string) A comma separated list. Only report operations for specified protocol(s). Default is all. 
 @return StatisticsOperations*/
func (a *StatisticsApiService) GetStatisticsOperations(ctx context.Context, localVarOptionals map[string]interface{}) (StatisticsOperations,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  StatisticsOperations
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/platform/3/statistics/operations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}


	if localVarTempParam, localVarOk := localVarOptionals["protocols"].([]string); localVarOk {
		localVarQueryParams.Add("protocols", parameterToString(localVarTempParam, "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* StatisticsApiService 
 Retrieve protocol list.
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "type_" (string) Specifies whether internal, external, or all protocols should be returned.
 @return StatisticsProtocols*/
func (a *StatisticsApiService) GetStatisticsProtocols(ctx context.Context, localVarOptionals map[string]interface{}) (StatisticsProtocols,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  StatisticsProtocols
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/platform/1/statistics/protocols"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["type_"], "string", "type_"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["type_"].(string); localVarOk {
		localVarQueryParams.Add("type", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* StatisticsApiService 
 
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "sort" (string) Sort data by the specified comma-separated field(s). (num_operations | operation_rate | in_max | in_min | in | in_avg | out_max | out_min | out | out_avg | time_max | time_min | time_avg | node | protocol | class | user_id | user_name | local_addr | local_name | remote_addr | remote_name) Prepend &#39;asc:&#39; or &#39;desc:&#39; to a field to change the sort direction. 
     @param "totalby" (string) A comma separated list specifying what should be unique. (node | protocol | class | local_addr | local_name | remote_addr | remote_name | user_id | user_name | devid). Aggregation is performed over all the fields not specified in the list.
     @param "userNames" (string) A comma separated list. Only report statistics for operations requested by users with resolved names enumerated. 
     @param "remoteAddresses" (string) A comma separated list. Only report statistics for operations requested by the remote clients with dotted-quad IP addresses enumerated. 
     @param "numeric" (bool) Do not resolve hostnames and usernames to their human readable form(s). Default is false. 
     @param "localNames" (string) A comma separated list. Only report statistics for operations handled by the local hosts with resolved names enumerated. 
     @param "userIds" (string) A comma separated list. Only report statistics for operations requested by users with numeric UIDs enumerated. 
     @param "classes" (string) A comma separated list. Default is all. (other | write | read | namespace_read | namespace_write)
     @param "timeout" (int32) Timeout remote commands after NUM seconds, where NUM is the integer passed to the argument.
     @param "localAddresses" (string) A comma separated list. Only report statistics for operations handled by the local hosts with dotted-quad IP addresses enumerated. 
     @param "degraded" (bool) Continue to report if some nodes do not respond.
     @param "remoteNames" (string) A comma separated list. Only report statistics for operations requested by the remote clients with resolved names enumerated. 
     @param "nodes" (string) A comma separated list. Specify node(s) for which statistics should be reported. Default is all. Zero (0) should be passed in as the sole argument to indicate local.
     @param "protocols" (string) A comma separated list. Default is all. (nfs3 | smb1 | nlm | ftp | http | siq | smb2 | nfs4 | papi | jobd | irp | lsass_in | lsass_out | hdfs | internal | external)
 @return SummaryClient*/
func (a *StatisticsApiService) GetSummaryClient(ctx context.Context, localVarOptionals map[string]interface{}) (SummaryClient,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  SummaryClient
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/platform/3/statistics/summary/client"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["sort"], "string", "sort"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["totalby"], "string", "totalby"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["userNames"], "string", "userNames"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["remoteAddresses"], "string", "remoteAddresses"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["numeric"], "bool", "numeric"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["localNames"], "string", "localNames"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["userIds"], "string", "userIds"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["classes"], "string", "classes"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["timeout"], "int32", "timeout"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["localAddresses"], "string", "localAddresses"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["degraded"], "bool", "degraded"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["remoteNames"], "string", "remoteNames"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["nodes"], "string", "nodes"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["protocols"], "string", "protocols"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["sort"].(string); localVarOk {
		localVarQueryParams.Add("sort", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["totalby"].(string); localVarOk {
		localVarQueryParams.Add("totalby", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["userNames"].(string); localVarOk {
		localVarQueryParams.Add("user_names", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["remoteAddresses"].(string); localVarOk {
		localVarQueryParams.Add("remote_addresses", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["numeric"].(bool); localVarOk {
		localVarQueryParams.Add("numeric", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["localNames"].(string); localVarOk {
		localVarQueryParams.Add("local_names", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["userIds"].(string); localVarOk {
		localVarQueryParams.Add("user_ids", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["classes"].(string); localVarOk {
		localVarQueryParams.Add("classes", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["timeout"].(int32); localVarOk {
		localVarQueryParams.Add("timeout", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["localAddresses"].(string); localVarOk {
		localVarQueryParams.Add("local_addresses", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["degraded"].(bool); localVarOk {
		localVarQueryParams.Add("degraded", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["remoteNames"].(string); localVarOk {
		localVarQueryParams.Add("remote_names", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["nodes"].(string); localVarOk {
		localVarQueryParams.Add("nodes", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["protocols"].(string); localVarOk {
		localVarQueryParams.Add("protocols", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* StatisticsApiService 
 
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "sort" (string) Sort data by the specified comma-separated field(s). (drive_id | type | xfers_in | bytes_in | xfer_size_in | xfers_out | bytes_out | xfer_size_out | access_latency | access_slow | iosched_latency | iosched_queue | busy | used_bytes_percent | used_inodes). Prepend &#39;asc:&#39; or &#39;desc:&#39; to a field to change the sort direction. 
     @param "degraded" (bool) Continue to report if some nodes do not respond.
     @param "type_" (string) Specify drive type(s) for which statistics should be reported.
     @param "nodes" (string) A comma separated list. Specify node(s) for which statistics should be reported. Default is all. Zero (0) should be passed in as the sole argument to indicate local.
     @param "timeout" (int32) Timeout remote commands after NUM seconds, where NUM is the integer passed to the argument.
 @return SummaryDrive*/
func (a *StatisticsApiService) GetSummaryDrive(ctx context.Context, localVarOptionals map[string]interface{}) (SummaryDrive,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  SummaryDrive
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/platform/3/statistics/summary/drive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["sort"], "string", "sort"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["degraded"], "bool", "degraded"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["type_"], "string", "type_"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["nodes"], "string", "nodes"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["timeout"], "int32", "timeout"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["sort"].(string); localVarOk {
		localVarQueryParams.Add("sort", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["degraded"].(bool); localVarOk {
		localVarQueryParams.Add("degraded", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["type_"].(string); localVarOk {
		localVarQueryParams.Add("type", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["nodes"].(string); localVarOk {
		localVarQueryParams.Add("nodes", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["timeout"].(int32); localVarOk {
		localVarQueryParams.Add("timeout", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* StatisticsApiService 
 File heat map, i.e. rate of file operations, and the type of operation listed by path/lin(s).
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "sort" (string) Sort data by the specified comma-separated field(s). (operation_rate | node | event_name | class_name | lin | path). Prepend &#39;asc:&#39; or &#39;desc:&#39; to a field to change the sort direction. 
     @param "convertlin" (bool) Convert lin to hex. Default is true. 
     @param "totalby" (string) A comma separated list specifying what should be unique. (node | event_name | event_class | operation_rate | path | lin). Aggregation is performed over all the fields not specified in the list.
     @param "pathdepth" (int32) Squash paths to this directory depth. Defaults to none, ie. the paths are not limited (Subject to the system limits.)
     @param "numeric" (bool) Do not resolve LINs into filenames. Default is false. 
     @param "events" (string) A comma separated list. Default is all. Only report specified event types(s). (blocked | contended | deadlocked | getattr | link | lock | lookup | read | rename | setattr | unlink | write).
     @param "maxpath" (int32) Maximum bytes allocated for looking up a path. An ASCII character is 1 byte (It may be more for other types of encoding). The default is 1024 bytes. Zero (0) means unlimited (Subject to the system limits.)
     @param "classes" (string) A comma separated list. Default is all. (other | write | read | namespace_read | namespace_write).
     @param "timeout" (int32) Timeout remote commands after NUM seconds, where NUM is the integer passed to the argument.
     @param "nodes" (string) A comma separated list. Specify node(s) for which statistics should be reported. Default is all. Zero (0) should be passed in as the sole argument to indicate local.
     @param "degraded" (bool) Continue to report if some nodes do not respond.
 @return SummaryHeat*/
func (a *StatisticsApiService) GetSummaryHeat(ctx context.Context, localVarOptionals map[string]interface{}) (SummaryHeat,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  SummaryHeat
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/platform/3/statistics/summary/heat"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["sort"], "string", "sort"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["convertlin"], "bool", "convertlin"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["totalby"], "string", "totalby"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["pathdepth"], "int32", "pathdepth"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["numeric"], "bool", "numeric"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["events"], "string", "events"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["maxpath"], "int32", "maxpath"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["classes"], "string", "classes"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["timeout"], "int32", "timeout"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["nodes"], "string", "nodes"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["degraded"], "bool", "degraded"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["sort"].(string); localVarOk {
		localVarQueryParams.Add("sort", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["convertlin"].(bool); localVarOk {
		localVarQueryParams.Add("convertlin", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["totalby"].(string); localVarOk {
		localVarQueryParams.Add("totalby", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["pathdepth"].(int32); localVarOk {
		localVarQueryParams.Add("pathdepth", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["numeric"].(bool); localVarOk {
		localVarQueryParams.Add("numeric", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["events"].(string); localVarOk {
		localVarQueryParams.Add("events", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["maxpath"].(int32); localVarOk {
		localVarQueryParams.Add("maxpath", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["classes"].(string); localVarOk {
		localVarQueryParams.Add("classes", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["timeout"].(int32); localVarOk {
		localVarQueryParams.Add("timeout", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["nodes"].(string); localVarOk {
		localVarQueryParams.Add("nodes", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["degraded"].(bool); localVarOk {
		localVarQueryParams.Add("degraded", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* StatisticsApiService 
 
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "operations" (string) Specify operation(s) for which statistics should be reported (See the cli command: &#39;isi statistics list operations&#39;, for a total list). Default is all. 
     @param "sort" (string) Sort data by the specified comma-separated field(s). (time | operation_count | operation_rate | in_max | in_min | in | in_avg | in_standard_dev | out_max | out_min | out | out_avg | out_standard_dev | time_max | time_min | time_avg | time_standard_dev | node | protocol | class | operation). Prepend &#39;asc:&#39; or &#39;desc:&#39; to a field to change the sort direction. 
     @param "totalby" (string) A comma separated list specifying what should be unique. (node | protocol | class | operation). Aggregation is performed over all the fields not specified in the list.
     @param "zero" (bool) Show table entries with no values.
     @param "classes" (string) A comma separated list. Default is all. (other | write | read | create | delete | namespace_read | namespace_write | file_state | session_state).
     @param "timeout" (int32) Timeout remote commands after NUM seconds, where NUM is the integer passed to the argument.
     @param "degraded" (bool) Continue to report if some nodes do not respond.
     @param "nodes" (string) A comma separated list. Specify node(s) for which statistics should be reported. Default is all. Zero (0) should be passed in as the sole argument to indicate local.
     @param "protocols" (string) A comma separated list. Default is all external protocols. (nfs3 | smb1 | nlm | ftp | http | siq | smb2 | nfs4 | papi | jobd | irp | lsass_in | lsass_out | hdfs | all | internal | external)
 @return SummaryProtocol*/
func (a *StatisticsApiService) GetSummaryProtocol(ctx context.Context, localVarOptionals map[string]interface{}) (SummaryProtocol,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  SummaryProtocol
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/platform/3/statistics/summary/protocol"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["operations"], "string", "operations"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["sort"], "string", "sort"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["totalby"], "string", "totalby"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["zero"], "bool", "zero"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["classes"], "string", "classes"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["timeout"], "int32", "timeout"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["degraded"], "bool", "degraded"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["nodes"], "string", "nodes"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["protocols"], "string", "protocols"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["operations"].(string); localVarOk {
		localVarQueryParams.Add("operations", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["sort"].(string); localVarOk {
		localVarQueryParams.Add("sort", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["totalby"].(string); localVarOk {
		localVarQueryParams.Add("totalby", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["zero"].(bool); localVarOk {
		localVarQueryParams.Add("zero", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["classes"].(string); localVarOk {
		localVarQueryParams.Add("classes", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["timeout"].(int32); localVarOk {
		localVarQueryParams.Add("timeout", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["degraded"].(bool); localVarOk {
		localVarQueryParams.Add("degraded", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["nodes"].(string); localVarOk {
		localVarQueryParams.Add("nodes", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["protocols"].(string); localVarOk {
		localVarQueryParams.Add("protocols", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* StatisticsApiService 
 
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "degraded" (bool) Continue to report if some nodes do not respond.
     @param "protocol" (string) A single protocol. Default is nfs3. (nfs3 | smb1 | nlm | ftp | http | siq | smb2 | nfs4 | papi | jobd | irp | lsass_in | lsass_out | hdfs)
     @param "nodes" (string) A comma separated list. Specify node(s) for which statistics should be reported. Default is all. Zero (0) should be passed in as the sole argument to indicate local.
     @param "timeout" (int32) Timeout remote commands after NUM seconds, where NUM is the integer passed to the argument.
 @return SummaryProtocolStats*/
func (a *StatisticsApiService) GetSummaryProtocolStats(ctx context.Context, localVarOptionals map[string]interface{}) (SummaryProtocolStats,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  SummaryProtocolStats
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/platform/3/statistics/summary/protocol-stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["degraded"], "bool", "degraded"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["protocol"], "string", "protocol"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["nodes"], "string", "nodes"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["timeout"], "int32", "timeout"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["degraded"].(bool); localVarOk {
		localVarQueryParams.Add("degraded", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["protocol"].(string); localVarOk {
		localVarQueryParams.Add("protocol", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["nodes"].(string); localVarOk {
		localVarQueryParams.Add("nodes", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["timeout"].(int32); localVarOk {
		localVarQueryParams.Add("timeout", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* StatisticsApiService 
 
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "sort" (string) Sort data by the specified comma-separated field(s). (time | node | cpu | smb | ftp | http | nfs | hdfs | total | net_in | net_out | disk_in). Prepend &#39;asc:&#39; or &#39;desc:&#39; to a field to change the sort direction. 
     @param "oprates" (bool) Display protocol operation rate statistics rather than the default throughput statistics.
     @param "degraded" (bool) Continue to report if some nodes do not respond.
     @param "nodes" (string) A comma separated list. Specify node(s) for which statistics should be reported. Default is all. Zero (0) should be passed in as the sole argument to indicate local.
     @param "timeout" (int32) Timeout remote commands after NUM seconds, where NUM is the integer passed to the argument.
 @return SummarySystem*/
func (a *StatisticsApiService) GetSummarySystem(ctx context.Context, localVarOptionals map[string]interface{}) (SummarySystem,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  SummarySystem
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/platform/3/statistics/summary/system"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["sort"], "string", "sort"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["oprates"], "bool", "oprates"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["degraded"], "bool", "degraded"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["nodes"], "string", "nodes"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["timeout"], "int32", "timeout"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["sort"].(string); localVarOk {
		localVarQueryParams.Add("sort", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["oprates"].(bool); localVarOk {
		localVarQueryParams.Add("oprates", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["degraded"].(bool); localVarOk {
		localVarQueryParams.Add("degraded", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["nodes"].(string); localVarOk {
		localVarQueryParams.Add("nodes", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["timeout"].(int32); localVarOk {
		localVarQueryParams.Add("timeout", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* StatisticsApiService 
 
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "sort" (string) Sort data by the specified comma-separated field(s). (node | system_name | job_type | cpu | reads | writes | l2 | l3). Prepend &#39;asc:&#39; or &#39;desc:&#39; to a field to change the sort direction. 
     @param "jobTypes" ([]string) A comma separated list. Only report statistics for job(s) specified by type, if configured. 
     @param "totalby" (string) A comma separated list specifying what should be unique. (node | system_name | job_type). Aggregation is performed over all the fields not specified in the list.
     @param "timeout" (int32) Timeout remote commands after NUM seconds, where NUM is the integer passed to the argument.
     @param "degraded" (bool) Continue to report if some nodes do not respond.
     @param "nodes" (string) A comma separated list. Specify node(s) for which statistics should be reported. Default is all. Zero (0) should be passed in as the sole argument to indicate local.
     @param "systemNames" (string) A comma separated list. Only report statistics for workloads specified by system names.
 @return SummaryWorkload*/
func (a *StatisticsApiService) GetSummaryWorkload(ctx context.Context, localVarOptionals map[string]interface{}) (SummaryWorkload,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  SummaryWorkload
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/platform/4/statistics/summary/workload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["sort"], "string", "sort"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["totalby"], "string", "totalby"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["timeout"], "int32", "timeout"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["degraded"], "bool", "degraded"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["nodes"], "string", "nodes"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["systemNames"], "string", "systemNames"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["sort"].(string); localVarOk {
		localVarQueryParams.Add("sort", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["jobTypes"].([]string); localVarOk {
		localVarQueryParams.Add("job_types", parameterToString(localVarTempParam, "csv"))
	}
	if localVarTempParam, localVarOk := localVarOptionals["totalby"].(string); localVarOk {
		localVarQueryParams.Add("totalby", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["timeout"].(int32); localVarOk {
		localVarQueryParams.Add("timeout", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["degraded"].(bool); localVarOk {
		localVarQueryParams.Add("degraded", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["nodes"].(string); localVarOk {
		localVarQueryParams.Add("nodes", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["systemNames"].(string); localVarOk {
		localVarQueryParams.Add("system_names", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

